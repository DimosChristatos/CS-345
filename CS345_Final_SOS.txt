 1) Ποιές είναι οι βασικές λειτουργίες ενός λειτουργικού συστήματος;

    1) Η διαχείριση των πόρων του υπολογιστή, όπως η CPU, η μνήμη, ο δίσκος, ο
       εκτυπωτής, κ.α.
    2) Η δημιουργία διεπαφής χρήση
    3) Η εκτέλεση και η παροχή υπηρεσιών για εφαρμογές λογισμικού

 2) Ποιά τα είδη των πυρήνων;

    1) Monolithic
       Ένας μονολιθικός πυρήνας είναι μια αρχιτεκτονική λειτουργικού
       συστήματος όπου ολόκληρο το λειτουργικό σύστημα (το οποίο περιλαμβάνει
       τους drivers, το file system, την επικοινωνία διεργασιών) λειτουργεί
       στον χώρο του πυρήνα.
       Είναι μεγάλο, πολύπλοκο, και όταν συμβαίνει κάποιο σφάλμα, τερματίζει
       όλο το λειτουργικό. Για μία μικρή αλλαγή σε ένα κομμάτι του, πρέπει να
       το κάνουμε compile ολόκληρο.

    2) Microkernel
       ένας μιρκοπυρήνας είναι το σχεδόν ελάχιστο ποσό λογισμικού που μπορεί
       να παρέχει τους μηχανισμούς που απαιτούνται για την υλοποίηση ενός
       λειτουργικού συστήματος. Αυτοί οι μηχανισμοί περιλαμβάνουν low-level
       address space management, thread management και inter-process
       communication (IPC).
       Οι παραδοσιακές λειτουργίες του λειτουργικού συστήματος, όπως οι device
       drivers, protocol stacks και τα file systems, συνήθως απομακρύνονται
       από τον ίδιο τον πυρήνα και αντίθετα τρέχουν στο χώρο του χρήστη.

    3) Layered Operating System
	Ένα πολυεπίπεδο λειτουργικό σύστημα είναι ένα λειτουργικό σύστημα που
	συγκεντρώνει τη σχετική λειτουργικότητα μαζί και τη χωρίζει από τα μη
	σχετικά.

	6) Operator (User)
	5) User program
	4) I/O Management
	3) Device Driver
	2) Memory Management
	1) Process Allocation Management
	0) Hardware

    (4) Exokernel
	Η αρχιτεκτονική exokernel έχει σχεδιαστεί για να διαχωρίζει την
	προστασία των πόρων από τη διαχείριση, για να διευκολύνει την
	προσαρμογή στις εφαρμογές.
	Τα exokernels είναι συνήθως μικρού μεγέθους λόγω της περιορισμένης
	λειτουργικότητάς τους.
	Εφαρμογές ή βιβλιοθήκες μπορούν να επικοινωνούν απευθείας με το
	hardware χωρίς να περάσουν από τον πυρήνα.

 3) Περιγράψτε την ιεραρχία μνήμης.

    Typical Access Time                 Typical Capacity

           1 nsec          Registers        < 1    KB
           2 nsec            Cache          ~ 1+   MB
          10 nsec         Main Memory       ~ 1+   GB
          10 msec        Magnetic Disk      ~ 100+ GB
         100  sec        Magnetic Tape      ~ 100+ GB

 4) Περιγράψτε την διαδικασία εκκίνησης. 

    1) Εκκινεί το BIOS και επιλέγει boot device, χρησιμοποιώντας πληροφορίες
       από την CMOS μνήμη.
    2) Εκτελεί τον κώδικα που βρίσκεται στο πρώτο sector (Master Boot Record)
       από το boot device
    3) Φορτώνει κώδικα από τον boot sector του active partition
    4) Ο boot sector φορτώνει και τρέχει τον bootloader από το filesystem του

 5) Τι είναι process, τι είναι thread και ποιά η διαφορά τους;

    Process είναι το στιγμιότυπο ενός προγράμματος που εκτελείται σε έναν
    υπολογιστή. Μια διεργασία αποτελείται από το ίδιο το πρόγραμμα και από
    κάποιες τιμές που περιέχονται στη μνήμη και στους καταχωρητές του
    επεξεργαστή. Έχει ένα address space με stack, heap, text και global
    μεταβλητές.

    Thread είναι η μικρότερη ακολουθία προγραμματισμένων εντολών που μπορεί να
    υποστεί διαχείριση ανεξάρτητα από το λειτουργικό σύστημα. Ένα νήμα είναι
    μια ελαφριά διεργασία.

    Ένα νήμα διαφέρει από μια διεργασία ενός πολυεπεξεργαστικού λειτουργικού
    συστήματος στα εξής:

    - οι διεργασίες είναι τυπικώς ανεξάρτητες, ενώ τα νήματα αποτελούν
      υποσύνολα μιας διεργασίας.

    - οι διεργασίες περιέχουν σημαντικά περισσότερες πληροφορίες κατάστασης από
      τα νήματα, ενώ πολλαπλά νήματα μιας διεργασίας μοιράζονται την κατάσταση
      της διεργασίας όπως επίσης μνήμη και άλλους πόρους.

    - οι διεργασίες έχουν ξεχωριστούς χώρους διευθυνσιοδότησης (address
      spaces), ενώ τα νήματα μοιράζονται το σύνολο του χώρου διευθύνσεων που
      τους παραχωρείται.

    - η εναλλαγή ανάμεσα στα νήματα μιας διεργασίας είναι πολύ γρηγορότερη από
      την εναλλαγή ανάμεσα σε διαφορετικές διεργασίες.

 6) Τι είναι το page table και τι το TLB;

    Page table είναι η δομή δεδομένων που χρησιμοποιείται από ένα
    σύστημα εικονικής μνήμης σε ένα λειτουργικό σύστημα υπολογιστή για να
    αποθηκεύει το mapping μεταξύ εικονικών διευθύνσεων και φυσικών
    διευθύνσεων.

    TLB είναι μια προσωρινή μνήμη cache που χρησιμοποιείται για τη μείωση του
    χρόνου που απαιτείται για την πρόσβαση σε μια θέση μνήμης χρήστη. Είναι
    μέρος της μονάδας διαχείρισης μνήμης (MMU) του chip. Το TLB αποθηκεύει τις
    πρόσφατες μεταφράσεις της εικονικής μνήμης στη φυσική μνήμη.

 7) Περιγράψτε το page fault και το TLB miss.

    Page fault είναι ένας τύπος εξαίρεσης που προκαλείται από το hardware όταν
    ένα τρέχον πρόγραμμα ζητά πρόσβαση σε μία σελίδα μνήμης, για την οποία δεν
    υπάρχει mapping στον page table.
    Η σελίδα ενδέχεται να είναι προσβάσιμη στο process, αλλά απαιτεί την
    προσθήκη mapping στο page table του process και μπορεί επιπλέον να απαιτεί
    το πραγματικό περιεχόμενο της σελίδας να φορτώνεται από το δίσκο.

    TLB miss είναι η αποτυχία εύρεσης του mapping μιας εικονικής διεύθυνσης στο
    TLB.

8) Ποιά τα είδη των interrupts και ποιά η διαδικασία εκτέλεσης ενός interrupt;

    1) Hardware interrupts
       Εάν το σήμα για τον επεξεργαστή προέρχεται από εξωτερική συσκευή ή υλικό.

    2) Software interrupts
       Εάν το σήμα για τον επεξεργαστή προέρχεται από μία εντολή λογισμικού.

    ---

    1) Το υλικό τοποθετεί στη στοίβα το PC, PSW, κτλ
    2) Το υλικό φορτώνει το νέο PC από το διάνυσμα διακοπής
    3) Η διαδικασία που είναι γραμμένη σε συμβολική γλώσσα αποθηκεύει τους
       registers
    4) Η διαδικασία που είναι γραμμένη σε συμβολική γλώσσα δημιουργεί νέα
       στοίβα
    5) Εκτελείται η εξυπηρέτηση διακοπής σε C
    6) Ο scheduler αποφασίζει ποια διεργασία θα εκτελεστεί αμέσως μετά
    7) Η Διαδικασία σε C επιστρέφει τον έλεγχο στην διαδικασία συμβολικής
       γλώσσας
    8) Η διαδικασία συμβολικής γλώσσας ξεκινάει την εκτέλεση της νέας
       διεργασίας

9) Διαφορές μεταξύ kernel threads και user level threads.
    
    User level threads
    Ο πυρήνας δε γνωρίζει για την ύπαρξη τους.
    
    Pros:
      * Τα user level threads μπορούν να υλοποιηθούν ακόμα και αν ο πυρήνας δεν
	υποστηρίζει νήματα.

      * Κάθε διεργασία έχει ένα πίνακα νημάτων για να παρακολουθεί τα νήματά
	της. Η εναλλαγή μεταξύ νημάτων είναι τουλάχιστον μία τάξη μεγέθους
	ταχύτερη από τη μέθοδο που περιλαμβάνει παγίδευση στον πυρήνα.

      * Επιτρέπουν σε κάθε διεργασία να διεθέτει το δικό της αλγόριθμο χρόνο
	προγραμματισμού. Μεγαλύτερη ευελιξία.

    Cons:
      * Εάν ένα user thread κάνει ένα system call, τότε θα μπλοκάρει και τα
        άλλα νήματα του ίδιου process.

      * Εάν ένα thread προκαλέσει ένα page fault, τότε ο πυρήνας θα μπλοκάρει
        όλο το process, με αποτέλεσμα να μπλοκάρει και τα υπόλοιπα threads.

      * Από τη στιγμή που ένα νήμα θα αρχίσει να εκτελείται, κανένα άλλο νήμα
	δεν μπορεί να εκτελεστεί μέχρι το εκτελούμενο να παραδώσει εκούσια τον
	έλεγχο της CPU.

      * Ένα άλλο μειονέκτημα είναι πως οι προγραμματιστές χρειάζονται τα νήματα
	ακριβώς στις εφαρμογές όπου αυτά μπλοκάρονται πιο συχνά. Τα νήματα αυτά
	ενεργοποιούν συνεχώς κλήσεις συστήματος. Ο πυρήνας δεν βλέπει τα
	υπόλοιπα νήματα για να τα επιλέξει προς εκτέλεση και έτσι τα άλλα
	νήματα μένουν μπλοκαρισμένα χωρίς να παράγουν καθόλου έργο.

    Kernel threads
    Ο πυρήνας διατηρεί ένα πίνακα νημάτων ο οποίος παρακολουθεί όλα τα
    υπάρχοντα νήματα στο σύστημα.
    Όταν ένα νήμα θέλει να δημιουργήσει ή να εξαλείψει ένα άλλο, πραγματοποιεί
    μια κλήση στον πυρήνα ο οποίος υλοποιεί τελικά τη δημιουργία ή την εξάλειψη
    ενημερώνοντας τα ταυτόχρονα τον πίνακα νημάτων.

    Pros:
      * Όταν μπλοκάρεται ένα νήμα πχ από ένα page fault, ο πυρήνας μπορεί να
        επιλέξει κάποιο άλλο προς εκτέλεση.
    
    Cons:
      * Το κόστος δημιουργίας, εξάλειψης και εναλλαγής είναι πολύ μεγάλο.
      * Τι θα συμβεί κατά την εκτέλεση ενός fork(); Θα έχει η νέα διεργασία
        όλα τα νήματα της προηγούμενης ή όχι;
      * Τι θα συμβεί εάν η διεργασία λάβει κάποιο signal; Ποιό νήμα θα το
        αναλάβει; Τι γίνεται αν 2 ή και παραπάνω δηλώσουν ενδιαφέρον;

10) Ποιά είναι τα states ενός process και ποιοί οι τύποι;

    - States
                      
      1) Running
         Τρέχει στη CPU
	 * Γίνεται Blocked πχ όταν περιμένει κάποιο I/O
	 * Γίνεται Ready όταν η CPU αρχίζει να εκτελεί μία άλλη διεργασία

      2) Ready
         Έτοιμη να τρέξη αλλά η CPU εκτελεί μία άλλη διεργασία
	 * Γίνεται Running όταν η CPU αρχίζει να εκτελεί αυτή τη διεργασία

      3) Blocked
         Περιμένει κάποιο εξωτερικό γεγονός
	 * Γίνεται Ready πχ όταν πραγματοποιηθεί το I/O

    - Types

      Χωρίζονται κυρίως σε:
      
      - Foreground
	Μια foreground process είναι οποιαδήποτε εντολή ή εργασία που εκτελείτε
	απευθείας και περιμένετε να ολοκληρωθεί. Ορισμένες foreground
	διεργασίες εμφανίζουν κάποιο είδος διεπαφής χρήστη που υποστηρίζει τη
	συνεχή αλληλεπίδραση του χρήστη

      - Background
	Μια background process είναι ένα πρόγραμμα που εκτελείται χωρίς είσοδο
	χρήστη.

      Επιπρόσθετα, κατηγοριοποιούνται σε:

      1) Zombie
         Τερμάτισε τη λειτουργία αλλά υπάρχει ακόμα στο process table

      2) Orphan
         Η πατρική διεργασία τερμάτισε καθώς αυτή ακόμα εκτελείται

      3) Daemon
         Τρέχει χωρίς τον έλεγχο ενός χρήστη (non-interactive)

11) Ποιοί είναι οι 4 λόγοι τερματισμού ενός process;

	1) Normal exit               (voluntary)  exit(0);
	2) Error exit                (voluntary)  exit(1);
	3) Fatal error               (involuntary) exception
	   e.g. divide with zero
	4) Killed by another process (involuntary)

12) Τι είναι η υβριδική υλοποίηση νημάτων και τι τα αναδυόμενα νήματα;
    
    Είναι μία προσπάθεια να συνδυαστούν τα πλεονεκτήματα των kernel threads και
    των user level threads. Σε αυτή τη προσέγγιση ο προγραμματιστής μπορεί να
    επιλέξει πόσα kernel threads θέλει και με πόσα user threads θα πολυπλέξει
    καθένα από τα πρώτα. Ο πυρήνας γνωρίζει και χειρίζεται μόνο τα kernel
    threads, χωρίς να γνωρίζει για τα user threads. Αυτή η προσέγγιση προσφέρει
    μέγιστη ευελιξία.

    Τα αναδυόμενα νήματα (pop-up threads) βρίσκουν χρήση στα κατανεμημένα
    συστήματα και αναλαμβάνουν το χειρισμό των εισερχόμενων μηνυμάτων.
    Ή έλευση ενός μηνύματος κάνει το σύστημα να δημιουργήσει ένα αναδυόμενο
    νήμα για τον χειρισμό του. Συνήθως χειρίζονται από τον πυρήνα, αν και
    έτσι μπορεί να προκαλέσει μεγάλη ζημιά.

13) Περιγράψτε τα race conditions.
    
    Είναι η κατάσταση κατά την οποία 2 (ή και παραπάνω) threads/processes
    γράφουν την ίδια θέση μνήμης, την ίδια χρονική στιγμή (χωρίς συγχρονισμό).

14) Ποιές είναι οι συνθήκες για την ικανοποίηση του αμοιβαίου αποκλεισμού;

    1) Το πολύ ένα process/thread στην κρίσιμη περιοχή
    2) Δεν επιτρέπονται παραδοχές σε ό,τι αφορά την ταχύτητα ή το πλήθος των
       επεξεργαστών
    3) Διεργασία που δε βρίσκεται σε κρίσιμο τμήμα δεν επιτρέπεται να μπλοκάρει
       άλλες διεργασίες
    4) Δεν επιτρέπεται μια διεργασία να αναμένει επαόριστον να μπει στην
       κρίσιμη περιοχή της

15) Τι είναι η κρίσιμες περιοχές;

    Μία κρίσιμη περιοχή είναι το τμήμα ενός προγράμματος που έχει πρόσβαση σε
    κοινόχρηστους πόρους. Μόνο όταν μια διεργασία βρίσκεται στην κρίσιμη
    περιοχή της, μπορεί να είναι σε θέση να διακόψει άλλες διαδικασίες.
    Μπορούμε να αποφύγουμε τα race conditions εξασφαλίζοντας ότι δεν
    εισέρχονται δύο διεργασίες ταυτόχρονα στις κρίσιμες περιοχές.

16) Τι είναι τα semaphores και τι τα mutexes;

    Semaphore είναι μία μεταβλητή που χρησιμοποιείται για τον έλεγχο πρόσβασης
    σε έναν κοινό πόρο από πολλαπλές διεργασίες σε ένα παράλληλο σύστημα
    Τα semaphores που περιορίζονται στις τιμές 0 και 1 (ή κλειδωμένα /
    ξεκλείδωτα, μη διαθέσιμα / διαθέσιμα) ονομάζονται binary semaphores και
    χρησιμοποιούνται για την υλοποίηση locks.

    Ένα mutex είναι ουσιαστικά το ίδιο με ένα binary semaphore και μερικές
    φορές έχει την ίδια υλοποίηση. Οι διαφορές μεταξύ τους είναι στον τρόπο με
    τον οποίο χρησιμοποιούνται.

17) Τι είναι ο scheduler;
    
    Είναι το κομμάτι αυτό του λειτουργικού συστήματος το οποίο είναι υπεύθυνο
    για το ποια διεργασία εκτελείται ανά πάσα στιγμή. Μπορεί να υλοποιεί μία ή
    περισσότερες πολιτικές χρονο προγραμματισμού, ανάλογα με την κατηγορία των
    διεργασιών.

18) Ποιές είναι οι κατηγορίες αλγορίθμων χρόνο-προγραμματισμού;

    1) Batch (Δέσμης)
       Στα συστήματα δέσμης δεν υπάρχουν χρήστες που αδημονούν στα τερματικά
       τους για γρήγορες απαντήσεις. Διαθέτουν σε κάθε διεργασία μεγάλα
       διαστήματα. Η προσέγγιση αυτή μειώνει τις εναλλαγές ανάμεσα στις
       διεργασίες, άρα βελτιώνει την απόδοση.

       Αλγόριθμοι:
       * Εξυπηρέτηση με βάση τη σειρά άφιξης
       * Εξυπηρέτηση με βάση τη μικρότερη διάρκεια
       * Εξυπηρέτηση με βάση τη μικρότερη διάρκεια που απομένει

    2) Interactive (Αλληλεπιδραστικά)
       Συστήματα τα οποία χαρακτηρίζονται από σημαντικές αλληλεπιδράσεις μεταξύ
       του χρήστη και του υπολογιστή / συστήματος.

       Αλγόριθμοι:
       * Round robin
       * Priority scheduling
       * Πολλαπλές ουρές
       * Εξυπηρέτηση με βάση τη μικρότερη διάρκεια
       * Εγγυημένος προγραμματισμός
       * Χρονοπρογραμματισμός με λοτταρία
       * Χρονοπρογραμματισμός δίκαιης διανομής

    3) Real-Time (Πραγματικού χρόνου)
       Συστήματα που έχουν περιορισμούς πραγματικού χρόνου.

19) Ποιοί οι στόχοι ενός αλγορίθμου χρόνο-προγραμματισμού;
    
    Για όλα τα συστήματα:
      
      - Δικαιοσύνη
        Nα εκχωρείται σε κάθε διεργασία ένα δίκαιο μερίδιο της CPU

      - Επιβολή της πολιτικής
        Nα παρακολουθείται αν εφαρμόζεται η καθορισμένη πολιτική

      - Ισορροπία
        Nα διατηρούνται ενεργά όλα τα τμήματα του συστήματος

    Επιπλέον για:

      * Συστήματα δέσμης
        
	- Διεκπεραιωτική ικανότητα
	  Να μεγιστοποιηθεί ο αριθμός των εργασιών που ολοκληρώνονται ανά ώρα
	
	- Χρόνος διεκπεραίωσης
	  Να ελαχιστοποιηθεί ο χρόνος που μεσολαβεί ανάμεσα στην υποβολή και
	  την ολοκλήρωση μιας εργασίας

	- Αξιοποίηση της CPU
	  Να διατηρείται η CPU συνεχώς ενεργός

      * Αλληλεπιδραστικά συστήματα

        - Χρόνος απόκρισης
	  Η απόκριση στις αιτήσεις να είναι ταχύτατη

	- Τήρηση αναλογιών
	  Να ικανοποιούνται οι προσδοκίες των χρηστών

      * Συστήματα πραγματικού χρόνου
        
	- Τήρηση των προθεσμιών
	  Να αποφεύγεται η απώλεια δεδομένων

	- Προβλεψιμότητα
	  Να αποφεύγεται ο υποβιβασμός της ποιότητας στα συστήματα πολυμέσων

20) Ποιοί οι τρόποι επίτευξης mutual exclution;

    1) Απενεργοποίηση διακοπών
       Θα απενεργοποιηθούν οι διακοπές ρολογιού καθώς και άλλες και έτσι η CPU
       δεν θα μπορεί να εναλλάξει την τρέχουσα διεργασία με κάποια άλλη.

    2) Μεταβλητές κλειδώματος (locks)

    3) Αυστηρή εναλλαγή

21) Τι είναι ο υποσιτισμός διεργασίας;

    Είναι ένα πρόβλημα που συναντάται σε παράλληλα συστήματα όπου μια
    διαδικασία στερείται συνεχώς τους απαραίτητους πόρους για να επεξεργαστεί
    το έργο της

22) Γράψτε το αλγόριθμο του Peterson.

    #define FALSE 0
    #define TRUE  1
    #define N     2

    int turn;
    int interested[N];

    void enter_region(int process)
    {
    	int other;

	other = 1 - process;
	interested[process] = TRUE;
	turn = process;
	while (turn == process && interested[other] == TRUE);
    }

    void leave_region(int process)
    {
    	interested[process] = FALSE;
    }

23) Busy-waiting (ενεργός αναμονή) σε μονο-επεξεγραστικά και σε
    πολυ-επεξεργαστικά συστήματα.

    Είναι μια τεχνική που χρησιμοποιείται όταν προγραμματίζουμε με
    νήματα/threads. Η ιδέα είναι ότι το νήμα τρέχει ένα βρόχο επανάληψης μέχρι
    να ικανοποιηθεί κάποια συνθήκη για να συνεχίσει.

    Συνήθως αποφεύγεται γιατί σπαταλάει χρόνο της CPU. Χρησιμοποιείται όταν
    υπάρχει σχετική βεβαιότητα ότι η αναμονή θα είναι σύντομη.

    Σε μονο-επεξεργαστικά συστήματα, το busy-waiting αποφεύγεται λόγω του ότι
    εάν το κύριο process κάνει busy-wait τότε μπλοκάρει όλο το σύστημα.

    Σε ένα πολυ-επεξεργαστικό σύστημα το busy-wait δεν θα παγώσει το σύστημα,
    ωστόσο και πάλι χάνονται κβάντα χωρίς παραγωγή έργου από το process.

24) Αναφέρετε χρήσεις του caching.
    
    1) Μείωση του network traffic / wait-time
       Κάνοντας cache δεδομένα δικτύου, δεν χρειάζεται να στέλνουμε ξανά πακέτα
       και να περιμένουμε απάντηση για δεδομένα που τα ζητήσαμε και στο σχετικά
       πρόσφατο παρελθόν (δεδομένου πως δεν έχουν υποστεί αλλαγές).

    2) Μείωση των main memory lookups
       Κάνοντας cache δεδομένα από προγράμματα, η CPU δεν χρειάζεται να τα
       ζητήσει από την κύρια μνήμη, με αποτέλεσμα τα προγράμματα να είναι πιο
       responsive.

    3) Μείωση των page table lookups
       Το TLB χρησιμοποιείται για να κάνει cache ορισμένα entries του page
       table.

25) Τι είναι η δρομολόγηση συγγένειας (affinity scheduling);
    
    Είναι μία τεχνική που εξασφαλίζει ότι μία διεργασία ή ένα thread μετά από
    κάποιο interrupt θα συνεχίσει να τρέχει στη ίδια CPU.

    Pros:
      - Μείωση των cache misses
	Η scheduler αφού εναλλάξει το process, θα το επαναφέρει στην ίδια CPU
	και ό,τι δεδομένα είχε η CPU στην cache της εξακολουθεί να τα
	χρησιμοποιεί. Εάν το process εκτελούνταν σε άλλη CPU μετά την εναλλαγή,
	εκείνη θα έπρεπε να φέρει στην cache της τα δεδομένα του, προκαλώντας
	τόσο cache miss στην ίδια όσο και cache invalidation στην προηγούμενη
	(εάν πείραζε τα δεδομένα)

26) Ποιό είναι το πρόβλημα αντιστροφής προτεραιοτήτων;
    
    Είναι ένα σενάριο στον προγραμματισμό στον οποίο μια εργασία υψηλής
    προτεραιότητας μπλοκάρεται έμμεσα από μια εργασία χαμηλότερης
    προτεραιότητας που αντιστρέφει τις σχετικές προτεραιότητες
    των δύο διεργασιών.
    Αυτό παραβιάζει το μοντέλο προτεραιότητας, σύμφωνα με το οποίο οι εργασίες
    υψηλής προτεραιότητας μπορούν να μπλοκαριστούν μόνο από εργασίες υψηλότερης
    προτεραιότητας

27) Τι είναι το φράγμα;

    Το φράγμα (barrier) είναι ένας μηχανισμός συγχρονισμού που προορίζεται
    κυρίως για ομάδες διεργασιών.
    Όταν μία διεργασία φτάσει σε ένα φράγμα, περιμένει να φτάσουν στο ίδιο
    φράγμα και οι υπόλοιπες διεργασίες για να συνεχίσει.

28) Τι είναι η σελιδοποίηση και γιατί επινοήθηκε;
    
    Είναι ένα σχήμα διαχείρισης μνήμης με το οποίο ένας υπολογιστής αποθηκεύει
    και ανακτά δεδομένα από δευτερεύουσα αποθήκευση, πχ δίσκο, για χρήση στην
    κύρια μνήμη. Σε αυτό το σχήμα, το λειτουργικό σύστημα ανακτά δεδομένα από
    το δίσκο σε μπλοκ ίδιου μεγέθους που ονομάζονται σελίδες.

    Επινοήθηκε για να δημιουργηθεί μεγάλος και γραμμικός χώρος διευθύνσεων
    χωρίς να χρειάζεται να επεκταθεί η φυσική μνήμη

29) Περιγράψτε τη δομή μίας σελίδας.

    ------------------------------------
    | ||| | A | B | C | D |     E      |
    ------------------------------------

    A: Bit για την απενεργοποίηση της κρυφής μνήμης για τη σελίδα αυτή
    B: Bit αναφοράς. Γίνεται set όταν το λειτουργικό αναφέρεται σε αυτή τη
       σελίδα, είτε για εγγραφή είτε για ανάγνωση
    C: Bit τροποποίησης. Γίνεται set όταν το λειτουργικό γράφει σε αυτή τη
       σελίδα. Αναφέρετε και ως βρώμικο bit
    D: Bit(s) προστασίας. Δηλώνουν ποιά είδη πρόσβασης επιτρέπονται
       
       * 1 bit:
         - 0: Επιτρέπεται ανάγνωση/εγγραφή
	 - 1: Μόνο ανάγνωση
       * 3 bit:
         - 1ο bit: ανάγνωση
	 - 2o bit: εγγραφή
	 - 3ο bit: εκτέλεση

    E: Αριθμός πλαισίου σελίδας

30) Περιγράψτε τους αλγόριθμους αντικατάστασης σελίδων.

    1) Βέλτιστος αλγόριθμος αντικατάστασης
       Αδύνατον να υλοποιηθεί. Αντικαθιστά πάντα τη σελίδα που θα ζητηθεί στο
       πιο μακρινό μέλλον, με σκοπό να καθυστερήσει το περισσότερο δυνατό ένα
       σφάλμα σελίδας. Υποθετικός αλγόριθμος, χρησιμοποιείται ως μέτρο
       σύγκρισης.

    2) Αλγόριθμος αντικατάστασης σελίδας NRU (Not Recently Used)
       Αντικαθιστά σελίδες με βάση τις παρακάτω κατηγορίες:

       0. Δεν έγινε αναφορά, δεν τροποποιήθηκε    |
       1. Δεν έγινε αναφορά, τροποποιήθηκε        | προτεραιότητα
       2. Έγινε αναφορά, δεν τροποποιήθηκε        |
       3. Έγινε αναφορά, τροποποιήθηκε            ν

    3) Αλγόριθμος αντικατάστασης FIFO

    4) Αλγόριθμος αντικατάστασης σελίδας της δεύτερης ευκαιρίας
       Παραλλαγή του FIFO οπού αντί να αντικαθίστανται απλά η παλαιότερη
       σελίδα, πρώτα εξετάζεται το bit αναφοράς. Εάν η σελίδα αναφέρθηκε
       πρόσφατα, ο αλγόριθμος επανατοποθετεί τη σελίδα στο τέλος της ουράς,
       δίνοντάς της έτσι μία δεύτερη ευκαιρία. Εάν όλες οι σελίδες αναφέρθηκαν
       πρόσφατα, ο αλγόριθμος μετατρέπεται σε έναν απλό FIFO αλγόριθμο.

    5) Αλγόριθμος αντικατάστασης ρολογιού
       Οι σελίδες οργανώνονται σε μία κυκλική λίστα. Υπάρχει ένα δείκτης που
       δεικτοδοτεί την παλαιότερη σελίδα. Σε ένα σφάλμα σελίδας έχουμε τα
       εξής:

         - Bit αναφοράς 0: Αφαιρείται η σελίδα
	 - Bit αναφοράς 1: Ο δείκτης προχωρά μία θέση

    6) Αλγόριθμος αντικατάστασης LRU (Least Recently Used)
       Σε ένα σφάλμα σελίδας, αφαιρείται η σελίδα που δεν έχει χρησιμοποιηθεί
       για το μεγαλύτερο χρονικό διάστημα.
       Αν και ο αλγόριθμος LRU είναι θεωρητικά υλοποιήσιμος, δεν είναι φθηνός.

    7) Αλγόριθμος αντικατάστασης σελίδας του συνόλου εργασίας
       Ο αλγόριθμος κάνει prepaging προσπαθώντας να διατηρεί στη μνήμη σελίδες
       που ανήκουν στο working set και να ελαχιστοποιήσει το πλήθος των
       page faults. Όπως και ο LRU, η υλοποίηση είναι κάπως ακριβή.

    8) Αλγόριθμος αντικατάστασης σελίδας WSClock
       Μοιάζει με τον αλγόριθμο του ρολογιού, όμως:

       Σε ένα σφάλμα σελίδας ελέγχουμε τη σελίδα στην οποία δείχνει ο δείκτης:

       - Αν η σελίδα έχει το bit αναφοράς 1, τότε το κάνουμε 0 και προχωράμε
         το δείκτη

       - Αν η σελίδα έχει το bit αναφοράς 0:
         
	 - Αν η σελίδα είναι καθαρή και ο χρόνος τελευταίας χρήσης είναι
	   μεγαλύτερος από ένα τ, τότε η σελίδα δεν ανήκει στο working set,
	   υπάρχει έγκυρο αντίγραφο στο δίσκο και έτσι η σελίδα αφαιρείται και
	   αντικαθίστανται από τη νέα σελίδα.

	 - Αν η σελίδα είναι βρώμικη, δεν μπορεί να αντικατασταθεί αμέσως,
	   διότι δεν υπάρχει έγκυρο αντίγραφο στο δίσκο. Έτσι
	   χρονο προγραμματίζεται η εγγραφή της στο δίσκο και ο δείκτης προχωρά
	   με την επόμενη σελίδα.
       
       Ο αλγόριθμος αυτός χρησιμοποιείται αρκετά και στην πράξη. Είναι
       αποδοτικός και εύκολος στην υλοποίηση.

30) Πώς χειρίζεται το σύστημα ένα σφάλμα σελίδας;

    1) Παγίδευση στον πυρήνα και αποθήκευση του PC στη στοίβα
    2) Μία ρουτίνα assembly αποθηκεύει τους registers, έπειτα καλεί το
       λειτουργικό σύστημα
    3) Το λειτουργικό σύστημα εντοπίζει ποιά σελίδα χρειάζεται
    4) Ελέγχει εάν η σελίδα είναι έγκυρη και επιτρέπεται η πρόσβαση σε αυτή
    5) Αν η σελίδα είναι βρώμικη, χρονο προγραμματίζεται η εγγραφή της στο
       δίσκο, και γίνεται context switch για να τρέξει άλλη διεργασία μέχρι
       να ολοκληρωθεί η εγγραφή
    6) Όταν η σελίδα είναι πλέον καθαρή, το λειτουργικό τη ζητάει από τον
       δίσκο και τη φέρνει στη μνήμη
    7) Όταν η σελίδα φτάσει στη μνήμη, ενημερώνεται ο page table
    8) Η διεργασία που προκάλεσε το σφάλμα χρονο προγραμματίζεται και το
       λειτουργικό επιστρέφει στην ρουτίνα συμβολικής γλώσσας
    9) Η ρουτίνα αυτή ξανά φορτώνει του registers και επιστρέφει στο χώρο του
       χρήστη για να συνεχιστεί η εκτέλεση

31) Τι είναι η τμηματοποίηση και γιατί επινοήθηκε;

    Είναι η τεχνική κατά την οποία ο χώρος εικονικών διευθύνσεων διαιρείται σε
    επιμέρους ανεξάρτητους χώρους διευθύνσεων, οι οποίοι λέγονται ονομάζονται
    (segments). Το κάθε τμήμα αποτελείται από μία γραμμική ακολουθία
    διευθύνσεων, από το 0 μέχρι κάποιο μέγιστο. Τα τμήματα μπορούν να
    αυξομειώνονται ανεξάρτητα χωρίς να επηρεάζονται.

    Επινοήθηκε για να επιτρέπει στα προγράμματα και τα δεδομένα να χωρίζονται
    σε λογικά ανεξάρτητους χώρους διευθύνσεων, και να υποβοηθείται η
    κοινοχρησία και η προστασία.

32) Ποιά τα πλεονεκτήματα της τμηματοποίησης;
    
    1) Απλούστευση του χειρισμού των δομών δεδομένων που αυξάνονται ή
       μειώνονται σε μέγεθος

    2) Διευκολύνει την κοινή χρήση διαδικασιών ή δεδομένων από πολλές
       διεργασίες, πχ κοινόχρηστες βιβλιοθήκες (shared libraries)
       Η βιβλιοθήκη μπορεί να τοποθετηθεί σε ένα τμήμα και να είναι διαθέσιμη
       σε πολλές διεργασίες, χωρίς να χρειάζεται να βρίσκεται στους χώρους
       διευθύνσεων όλων των διεργασιών.

33) Σε συστήματα που κατανέμουν τα αρχεία τμηματικά, ποιό το μειονέκτημα των
    μεγάλων blocks και ποιό αυτό των μικρών blocks;

    - Μεγάλα blocks => σπατάλη χώρου  (μικρά αρχεία σε μεγάλα blocks)
    - Μικρά blocks  => σπατάλη χρόνου (πολλές περιστροφές του δίσκου)

34) Ποιές οι διαφορές μεταξύ paging και segmentation.

    1) Στο paging ο χρήστης δεν χρειάζεται να είναι ενήμερος πως
       χρησιμοποιείται η συγκεκριμένη τεχνική, στο segmentation χρειάζεται.

    2) Στο paging υπάρχει 1 γραμμικός χώρος διευθύνσεων, στο segmentation
       πολλοί.

    3) Στο paging οι διαδικασίες και τα δεδομένα δεν είναι διακριτά και δεν
       προστατεύονται ξεχωριστά, ενώ στο segmentation συμβαίνει.

    4) Στο segmentation είναι ευκολότερος ο χειρισμός πινάκων μεταβλητού
       μεγέθους

    5) Στο segmentation είναι ευκολότερη η κοινή χρήση των διαδικασιών ανάμεσα
       στους χρήστες 

35) Ποιές είναι οι 3 θεμελιώδεις απαιτήσεις για μακρόχρονη αποθήκευση
    πληροφοριών;

    1) Πρέπει να είναι δυνατόν να αποθηκεύονται μεγάλες ποσότητες πληροφοριών
    2) Οι πληροφορίες πρέπει να επιβιώνουν μετά από τον τερματισμό της
       διεργασίας που τις χρησιμοποιεί
    3) Πρέπει να επιτρέπεται σε πολλές διεργασίες να έχουν τη δυνατότητα να
       προσπελάσουν ταυτόχρονα τις πληροφορίες

36) Τι είναι τα αρχεία και ποιοί οι τύποι τους;

    Είναι λογικές μονάδες πληροφοριών τις οποίες δημιουργούν οι διεργασίες

    Τύποι:
      
      1) Κανονικά αρχεία
         Περιέχουν πληροφορίες χρήστη

      2) Κατάλογοι
         Βοηθούν στη δόμηση του συστήματος αρχείων

      3) Αρχεία χαρακτήρων
	 Σχετίζονται με την είσοδο / έξοδο και χρησιμοποιούνται για να
	 μοντελοποιήσουν σειριακές συσκευές Ε/Ε όπως τα τερματικά, εκτυπωτές,
	 και τα δίκτυα.

      4) Αρχεία μπλοκ
         Χρησιμοποιούνται για να μοντελοποιήσουν δίσκους

37) Τι είναι ο μαγικός αριθμός (magic number);
    
    Είναι ο αριθμός στην κεφαλίδα ενός αρχείου που υποδηλώνει πως το αρχείο
    αυτό είναι εκτελέσιμο.

38) Ποιά η μορφή ενός εκτελέσιμου αρχείου UNIX;
    
    +----------------------+
    |    Μαγικός αριθμός   |
    +----------------------+
    |    Μέγεθος κώδικα    |
    +----------------------+
    |   Μέγεθος δεδομένων  |
    +----------------------+
    |      Μέγεθος BSS     |
    +----------------------+
    |    Μέγεθος πίνακα    |
    |      συμβόλων        |
    +----------------------+
    |    Σημείο εισόδου    |
    +----------------------+
    |  ////////////////    |
    +----------------------+
    |       Σημαίες        |
    +----------------------+
    |                      |
    |       Κώδικας        |
    |                      |
    +----------------------+
    |                      |
    |       Δεδομένα       |
    |                      |
    +----------------------+
    | Bit επανατοποθέτησης | 
    +----------------------+
    |                      |
    |   Πίνακας συμβόλων   |
    |                      |
    +----------------------+

39) Αναφέρετε μερικά χαρακτηριστικά αρχείων.

    1) Current size
    2) Time of last access
    3) Time of last change
    4) Creator
    5) Owner
    6) Protection / permissions
    7) Hidden flag
    8) Creation time
    9) Password
         ...

40) Αναφέρετε μερικές λειτουργίες αρχείων.

    1) Create
    2) Delete
    3) Open
    4) Close
    5) Read
    6) Write
    7) Append
    8) Seek
    9) Rename
        ...

41) Περιγράψτε τις μεθόδους αποθήκευσης αρχείων.

    1) Συνεχής κατανομή
       Η πιο απλή μέθοδος κατανομής. Κάθε αρχείο αποθηκεύεται ως μία συνεχόμενη
       αλληλουχία μπλοκ δίσκου.

       Pros:

       1) Απλή στην υλοποίηση. Για την εύρεση των μπλοκ ενός αρχείου στο δίσκο
          χρειαζόμαστε μονάχα τη διεύθυνση του 1ου μπλοκ και τον αριθμό των
	  μπλοκ του αρχείου

       2) Η απόδοση κατά την ανάγνωση είναι εξαιρετική, επειδή μπορεί να
          διαβαστεί ολόκληρο το αρχείο από το δίσκο με μία λειτουργία

       Cons:

       1) Με την πάροδο του χρόνου, ο δίσκος κατατέμνεται. Έτσι ο δίσκος θα
	  καταλήξει να περιέχει αρχεία και κενά τμήματα. Για να γεμίσει τα κενά
	  αυτά, θα πρέπει ο προγραμματιστής να δηλώνει πριν επεξεργαστεί ένα
	  αρχείο, ποιό θα είναι το μέγεθος του τελικού αρχείου, προκειμένου να
	  μπορέσει το λειτουργικό να βρει μία θέση για να το αποθηκεύσει. Αυτό
	  καθιστά την συνεχή κατανομή μη πρακτική.

       Η συνεχής κατανομή βρίσκει χρήσεις στην αποθήκευση αρχείων σε CD-ROM,
       όπου το μέγεθος των δεδομένων είναι γνωστό εκ των προτέρων.

    2) Κατανομή συνδεδεμένης λίστας
       Τα μπλοκ του κάθε αρχείου βρίσκονται σε μία συνδεδεμένη λίστα. Το κάθε
       μπλοκ περιέχει ένα δείκτη στη διεύθυνση του επόμενου κατά σειρά μπλοκ.
       Ο κατάλογος μπορεί να αποθηκεύσει το δείκτη του 1ου μπλοκ ως αφετηρία.
       
       Pros:

       1) Δεν υπάρχει απώλεια χώρου εξαιτίας κατάτμησης

       Cons:

       2) Η τυχαία προσπέλαση είναι πάρα πολύ αργή. Για να διαβαστεί ένα αρχείο
	  θα πρέπει να γίνουν τόσες τυχαίες προσπελάσεις όσα και τα μπλοκ του
	  αρχείου. Επομένως οι αναγνώσεις είναι εξαιρετικά χρονοβόρες.

    3) Κατανομή συνδεδεμένης λίστας με χρήση πίνακα στη μνήμη
       Εδώ επεκτείνουμε την κατανομή συνδεδεμένης λίστας και χρησιμοποιούμε
       ένα Πίνακα Κατανομής Αρχείων (FAT - File Allocation Table). Ο πίνακας
       αυτός αποθηκεύει τους δείκτες όλων των μπλοκ των αρχείων στη μνήμη.

       Pros:

       Η προσπέλαση της αλυσίδας, δηλαδή των δεικτών των μπλοκ, γίνεται χωρίς
       τυχαία προσπέλαση στο δίσκο. Εάν για παράδειγμα θέλουμε το 100ο μπλοκ
       ενός αρχείου, η διεύθυνση αυτού θα βρίσκεται στη μνήμη, επομένως δε
       χρειάζεται να εκτελέσουμε 100 τυχαίες προσπελάσεις στο δίσκο για να τη
       βρούμε. Για την προσπέλαση του ίδιου του μπλοκ ωστόσο, θα πρέπει να
       μπούμε στο δίσκο.

       Cons:

       Η αποθήκευση ολόκληρου του πίνακα στη μνήμη.

    4) Κόμβοι i
       Μία μέθοδος που συσχετίζει κάθε αρχείο με ένα κόμβο i, μία δομή
       δεδομένων που περιέχει τα χαρακτηριστικά και τις διευθύνσεις των μπλοκ
       του αρχείου στο δίσκο (όχι όλες). Ο κόμβος i πρέπει να βρίσκεται στη
       μνήμη μονάχα όταν το αρχείο είναι ανοιχτό.

       Pros:

       1) Ο κόμβος i είναι συνήθως μικρότερος από το FAT.

       2) Αρχεία που δεν είναι ανοιχτά, δεν καταλαμβάνουν χώρο στη κύρια μνήμη

       Cons:

       1) Επιβάλλεται μία ιεραρχία από μπλοκ διευθύνσεων εάν τα αρχεία
	  αποτελούνται από πολλά μπλοκ. Το τελευταίο κελί του κόμβου i θα
	  περιέχει τη διεύθυνση ενός τέτοιου μπλοκ διευθύνσεων.

42) Περιγράψτε τα συστήματα αρχείων με καταγραφική δομή (LFS).
    
    Όλες οι εγγραφές τοποθετούνται σε προσωρινή μνήμη, και γράφονται περιοδικά
    στο δίσκο σε ένα μόνο τμήμα, στο τέλος του αρχείου καταγραφής (log). Κατά
    το άνοιγμα ενός αρχείου χρησιμοποιείται ο χάρτης για να εντοπιστεί ο κόμβος
    i για το αρχείο. Από τη στιγμή που θα εντοπιστεί ο κόμβος i, οι διευθύνσεις
    του μπλοκ μπορούν να βρεθούν από αυτόν. Όλα τα μπλοκ βρίσκονται σε τμήματα
    κάπου μέσα στο αρχείο καταγραφής.
    Το LFS χρησιμοποιεί ένα νήμα καθαρισμού (cleaner thread) που σαρώνει
    συνεχώς κυκλικά το αρχείο καταγραφής για να το συμπτύξει.

43) Περιγράψτε τα εικονικά συστήματα αρχείων (VFS)

    Η βασική ιδέα είναι να δημιουργηθεί μια αφαίρεση εκείνου του μέρους του
    συστήματος αρχείων που είναι κοινό σε όλα τα συστήματα αρχείων και να
    τοποθετηθεί ο κώδικάς τους σε ένα ξεχωριστό επίπεδο το οποίο καλεί τα
    υποκείμενα πραγματικά συστήματα αρχείων για να χειριστούν τα δεδομένα.

    Στόχος είναι να ενσωματώσουν πολλά συστήματα αρχείων σε μία τακτοποιημένη
    δομή.

    Το VFS διαθέτει δύο ξεχωριστές διασυνδέσεις:

    1) Την ανώτερη με τις διεργασίες χρήστη
    2) Την κατώτερη με τα πραγματικά συστήματα αρχείων

44) Περιγράψτε την αναζήτηση του ονόματος διαδρομής /usr/ast/mbox

    0) Στο Unix ο κόμβος i του βασικού καταλόγου βρίσκεται σε συγκεκριμένη θέση
       του δίσκου.

    1) Από αυτόν τον κόμβο i, το λειτουργικό σύστημα βρίσκει το βασικό κατάλογο
       ο οποίος μπορεί να βρίσκεται οπουδήποτε στο δίσκο.

    2) Το λειτουργικό σύστημα διαβάζει το βασικό κατάλογο και ψάχνει εκεί για
       να βρει το πρώτο στοιχείο της διαδρομής, usr, ώστε να εντοπίσει τον
       αριθμό κόμβου i του αρχείου /usr

    3) Από τον κόμβο i το σύστημα εντοπίζει τον κατάλογο /usr, τον διαβάζει και
       ψάχνει σε αυτόν για το επόμενο στοιχείο της διαδρομής, ast

    4) Αφού εντοπίσει τον κόμβο i για τον κατάλογο ast, διαβάζει τον κατάλογο
       ast και ψάχνει στον κατάλογο αυτό για το mbox.

    5) Αφού βρεθεί ο κόμβος i για το mbox, διαβάζεται ο κατάλογος/αρχείο στη
       μνήμη και παραμένει εκεί μέχρι να κλείσει το αρχείο

    Για κάθε κατάλογο/αρχείο, χρειάζομαι 1 read για το i node και 1 read για
    τα blocks του καταλόγου/αρχείου.

45) Τι είναι ο ελεγκτής συσκευών (device controller);
    
    Αποτελεί το ηλεκτρονικό κομμάτι μίας μονάδας Ε/Ε.
    Μεταφράζει τα σήματα που πηγαίνουν και προέρχονται από την CPU.

46) Τι είναι η Ε/Ε με χαρτογράφηση στη μνήμη (Memory Mapped I/O);

    Αποτελεί μία μέθοδο για εκτέλεση εισόδου/εξόδου (I/O) μεταξύ της κεντρικής
    μονάδας επεξεργασίας (CPU) και των περιφερειακών συσκευών σε έναν
    υπολογιστή.
    Χρησιμοποιεί τον ίδιο χώρο διευθύνσεων για την αντιμετώπιση τόσο των
    συσκευών μνήμης όσο και των συσκευών I/O. Έτσι, όταν η CPU αποκτά πρόσβαση
    σε μια διεύθυνση, μπορεί να αναφέρεται σε ένα τμήμα της φυσικής μνήμης RAM,
    ή μπορεί να αναφέρεται στη μνήμη της συσκευής εισόδου / εξόδου.

47) Τι είναι η άμεση προσπέλαση μνήμης (DMA);

    Είναι μια λειτουργία των συστημάτων υπολογιστών που επιτρέπει σε ορισμένα
    υποσυστήματα υλικού να έχουν πρόσβαση στην κύρια μνήμη του συστήματος
    (μνήμη τυχαίας προσπέλασης), ανεξάρτητα από την κεντρική μονάδα
    επεξεργασίας (CPU).
    Είναι απαραίτητη η παρουσία ενός ελεγκτή DMA.

48) Σχολιάστε για ακριβής vs ανακριβής διακοπές.

    Ακριβής διακοπές:
    Μια διακοπή που αφήνει τη μηχανή σε καλά ορισμένη κατάσταση ονομάζεται
    ακριβής διακοπή (precise interrupt) και έχει 4 ιδιότητες:

    1) Ο PC αποθηκεύεται σε γνωστή θέση
    2) Όλες οι εντολές πριν από αυτή στην οποία δείχνει ο PC έχουν ολοκληρωθεί
    3) Δεν έχει εκτελεστεί καμία εντολή μετά από αυτή στην οποία δείχνει ο PC
    4) Η κατάσταση εκτέλεσης της εντολής στην οποία δείχνει ο PC είναι γνωστή

    Ανακριβής διακοπές:
    Οι διακοπές που δεν πληρούν τις παραπάνω προδιαγραφές ονομάζονται
    ανακριβείς διακοπές.
    Όταν συμβαίνει μία ανακριβής διακοπή, το σύστημα συνήθως αδειάζει μεγάλες
    ποσότητες πληροφοριών της εσωτερικής του κατάστασης στη στοίβα, ώστε να
    δώσει στο λειτουργικό σύστημα τη δυνατότητα να εξακριβώσει τι ακριβώς
    συμβαίνει.

49) Ποιοί είναι οι στόχοι του λογισμικού Ε/Ε;

    1) Ανεξαρτησία από τη συσκευή (device independence)
       Να είναι δυνατή η γραφή προγραμμάτων τα οποία θα μπορούν να προσπελάσουν
       οποιαδήποτε συσκευή Ε/Ε χωρίς να χρειάζεται να καθορίζεται εκ των
       προτέρων η συσκευή.

    2) Ομοιόμορφη ονομασία (uniform naming)
       Το όνομα ενός αρχείου ή μίας συσκευής πρέπει να είναι απλώς μία
       συμβολοσειρά ή ένας ακέραιος και να μην εξαρτάται καθόλου από την
       εκάστοτε συσκευή.

    3) Χειρισμός σφαλμάτων (error handling)
       Να συμβαίνει όσο το δυνατόν πλησιέστερα στο υλικό.

    4) Προσωρινή αποθήκευση (buffering)

50) Ποιοί είναι οι τρόποι πραγματοποίησης Ε/Ε;

    1) Προγραμματισμένη Ε/Ε

       Συχνά υλοποιείται με:
       - Περιόδευση (polling) ή
       - Αναμονή με απασχόληση (busy waiting)

       Pros:

       1) Είναι απλή

       Cons:

       1) Δεσμεύει τη CPU

    2) Ε/Ε οδηγούμενη από διακοπές

       Αντί η CPU να περιμένει τη μονάδα Ε/Ε να τελειώσει, αφού της στείλει τα
       δεδομένα, καλεί τον χρονο προγραμματιστή και αρχίζει να εκτελεί μία άλλη
       διεργασία. Μόλις η μονάδα Ε/Ε τελειώσει τη δουλειά της και είναι έτοιμη
       πάλι να δεχτεί δεδομένα από τη CPU, παράγει ένα interrupt το οποίο θα
       διακόψει τη CPU. Αυτή στέλνει εκ νέου δεδομένα και ξανά καλεί το χρονο
       προγραμματιστή για να εκτελέσει κάποια άλλη διεργασία, κοκ.

       Pros:

       1) Καλύτερη διαχείριση του χρόνου της CPU

       Cons:

       1) Οι διακοπές είναι γενικά χρονοβόρες
       

    3) Ε/Ε με τη χρήση DMA
       
       Η ιδέα εδώ είναι να ανατεθεί στον ελεγκτή DMA η τροφοδοσία της μονάδας
       Ε/Ε, χωρίς να απασχολείται η CPU. Στην ουσία, η DMA είναι
       προγραμματισμένη Ε/Ε, μόνο που όλη η δουλειά γίνεται από τον ελεγκτή DMA
       αντί από τη CPU.

       Pros:

       1) Μειώνεται ο αριθμός των διακοπών

       Cons:

       1) Ο ελεγκτής DMA είναι συνήθως πολύ πιο αργός από τη CPU

51) Ποιά τα επίπεδα λογισμικού Ε/Ε;

 +----------------------------------------------+
 |                                              | Δημιουργία κλήσης Ε/Ε,
 |       Λογισμικό Ε/Ε επιπέδου χρήστη          | μορφοποίηση Ε/Ε, παροχέτευση 
 |                                              | 
 +----------------------------------------------+ 
 |                                              | Ονομασία, προστασία,
 | Λογισμικό λειτουργικού συστήματος ανεξάρτητο | μπλοκάρισμα, προσωρινή, 
 |             από τις συσκευές                 | αποθήκευση, κατανομή
 |                                              |
 +----------------------------------------------+
 |                                              | Αφύπνιση οδηγού όταν
 |              Οδηγοί συσκευών                 | ολοκληρωθεί η λειτουργία Ε/Ε
 |                                              |
 +----------------------------------------------+
 |            Χειριστές διακοπών                | Εκτέλεση της λειτουργίας Ε/Ε
 +----------------------------------------------+

52) Ποιές οι ενέργειες του χειριστή διακοπών όταν συμβαίνει μία διακοπή;

    1) Αποθηκεύει όσους registers δεν έχει αποθηκεύσει το υλικό
    2) Καθορίζει το περιβάλλον για τη διαδικασία εξυπηρέτησης διακοπής
    3) Δημιουργεί μία στοίβα για τη διαδικασία εξυπηρέτησης διακοπής
    4) Στέλνει επιβεβαίωση στον ελεγκτή διακοπών και  απενεργοποιεί τις
       διακοπές
    5) Αντιγράφει τους registers από τη στοίβα στον πίνακα διεργασιών
    6) Εκτελεί τη διαδικασία εξυπηρέτησης της διακοπής
    7) Επιλέγει τη διεργασία που πρόκειται να εκτελεστεί στη συνέχεια
    8) Καθορίζει το περιβάλλον για τη διεργασία που θα εκτελεστεί αμέσως
       μετά
    9) Φορτώνει τους registers της νέας διεργασίας
   10) Ξεκινά την εκτέλεση της νέας διεργασίας

53) Τι είναι οι οδηγοί συσκευών (device drivers);

    Κάθε συσκευή Ε/Ε συνδεδεμένη στον υπολογιστή χρειάζεται κώδικα
    εξειδικευμένο για τον έλεγχό της. Ο κώδικας αυτός ονομάζεται οδηγός
    συσκευής.

54) Τι γνωρίζετε για το μείζονα και τον ελάσσονα αριθμό συσκευής;

    Μείζονας αριθμός συσκευής (major device number)
    Χρησιμοποιείται για να εντοπιστεί ο κατάλληλος οδηγός συσκευής.

    Ελάσσονας αριθμός συσκευής (minor device number)
    Μεταβιβάζεται ως παράμετρος στον οδηγό για να προσδιορίζει τη μονάδα στην
    οποία πρέπει να γίνει η ανάγνωση ή η εγγραφή.

55) Τι είναι η διπλή προσωρινή αποθήκευση (double buffering)
    
    Αποτελεί μία τεχνική Ε/Ε κατά την οποία όταν γεμίσει ένας buffer πχ κατά
    την είσοδο δεδομένων από ένα μόντεμ, μέχρι αντιγραφούν τα δεδομένα του
    buffer από τον πυρήνα στο χώρο χρήστη, νέα δεδομένα εισερχόμενα από το
    μόντεμ μπορούν να αποθηκεύονται σε έναν δευτερεύον buffer. Όταν και αυτός
    γεμίσει, επαναχρησιμοποιείται ο 1ος, αφού τώρα θα είναι άδειος. Η
    διαδικασία πάει εναλλάξ.

56) Τι είναι η κυκλική προσωρινή μνήμη (circular buffer);

    Αποτελείται από μία περιοχή της μνήμης και δύο δείκτες. Ο ένας δείκτης
    δείχνει στην επόμενη ελεύθερη λέξη, όπου μπορούν να τοποθετηθούν νέα
    δεδομένα. Ο άλλος δείκτης δείχνει στην πρώτη λέξη δεδομένων στην προσωρινή
    μνήμη, η οποία δεν έχει ακόμη αφαιρεθεί. Σε πολλές περιπτώσεις, το υλικό
    προωθεί το πρώτο δείκτη καθώς προσθέτει νέα δεδομένα και το λειτουργικό
    σύστημα προωθεί το δεύτερο δείκτη καθώς αφαιρεί και επεξεργάζεται τα
    δεδομένα. Και οι δύο δείκτες επιστρέφουν κυκλικά στη βάση όταν φτάσουν στην
    κορυφή. 

57) Περιγράψτε τα επίπεδα RAID.

    1) RAID 0 (Disk striping)

       Διαιρεί δεδομένα σε οποιονδήποτε αριθμό δίσκων και επιτρέπει υψηλότερο
       throughput. Ένα μεμονωμένο αρχείο διαβάζεται από πολλαπλούς δίσκους.
       Αυτό το επίπεδο RAID έχει το πλεονέκτημα του υψηλού performance, ωστόσο
       δεν είναι fault tolerant διότι δεν κρατάει αντίγραφα των δεδομένων.

    2) RAID 1 (Disk Mirroring)

       Γράφει και διαβάζει ταυτόσημα δεδομένα σε ζεύγη μονάδων δίσκου.  Αυτή η
       διαδικασία ονομάζεται συχνά mirroring δεδομένων και η κύρια λειτουργία
       της είναι η παροχή αντιγράφων. Εάν κάποιος από τους δίσκους στη
       αποτύχει, το σύστημα μπορεί ακόμα να έχει πρόσβαση στα δεδομένα από τους
       υπόλοιπους δίσκους.

    3) RAID 5 (Striping with parity)

       Διαιρεί τα αρχεία σε πολλαπλούς δίσκους, όπως το RAID 0 και επιπλέον
       αποθηκεύει extra πληροφορίες (μικρό μέγεθος δεδομένων που μπορούν να
       περιγράψουν με ακρίβεια μεγαλύτερα ποσά δεδομένων), το οποίο
       χρησιμοποιείται για την ανάκτηση των δεδομένων σε περίπτωση αποτυχίας
       δίσκου.

    4) RAID 6 (Striping with double parity)

       Το Raid 6 είναι παρόμοιο με το RAID 5, ωστόσο, παρέχει αυξημένη
       αξιοπιστία καθώς αποθηκεύει ένα επιπλέον πακέτο πληροφορίας.
       Αυτό ουσιαστικά σημαίνει ότι είναι δυνατό για δυο δίσκους να αποτύχουν
       ταυτόχρονα χωρίς να υπάρξει πρόβλημα.

    5) RAID 10 (Striping + Mirroring)

       Το RAID 10 συνδυάζει το mirroring της RAID 1 με το striping του RAID 0.
       Ή με άλλα λόγια, συνδυάζει τα αντίγραφα του RAID 1 με την αυξημένη
       απόδοση του RAID 0

58) Περιγράψτε τη μορφή ενός τομέα δίσκου (disk sector).
    
    +---------------------------------+
    |          |                |     |
    | Προοίμιο |    Δεδομένα    | ECC |
    |          |                |     |
    +---------------------------------+

    - Προοίμιο
      Μία συγκεκριμένη ακολουθία από bits που επιτρέπει στο υλικό να
      αναγνωρίζει την αρχή του τομέα. Περιέχει επίσης τους αριθμούς κυλίνδρου
      και τομέα και κάποιες άλλες πληροφορίες.
    
    - Δεδομένα
      Το μέγεθος του τμήματος δεδομένων προσδιορίζεται από το πρόγραμμα που
      κάνει τη διαμόρφωση χαμηλού επιπέδου.

    - ECC
      Το πεδίο ECC (error-correcting code) περιέχει πλεονάζουσες πληροφορίες οι
      οποίες μπορούν να χρησιμοποιηθούν κατά την ανάκαμψη από σφάλματα
      ανάγνωσης.

59) Ποιοί οι παράγοντες που επηρεάζουν τον χρόνο ανάγνωσης του δίσκου;

    1) Χρόνος αναζήτησης (seek time - ο χρόνος που χρειάζεται για να
       μετακινηθεί ο βραχίονας στον κατάλληλο κύλινδρο)

    2) Καθυστέρηση λόγω περιστροφής (rotational delay - ο χρόνος που χρειάζεται
       για να περιστραφεί ο κατάλληλος τομέας κάτω από την κεφαλή)

    3) Χρόνος μεταφοράς δεδομένων

60) Περιγράψτε τους αλγόριθμους περιστροφής του βραχίονα.
    
    1) Εξυπηρέτηση με βάση τη σειρά άφιξης (FCFS - First Come First Served)
       Ο οδηγός του δίσκου εξυπηρετεί τις αιτήσεις μία-μία, με τη σειρά που
       φτάνουν

    2) Πρώτα η Συντομότερη Αναζήτηση (SSF - Shortest Seek First)
       Ο οδηγός εξυπηρετεί πρώτα την πιο κοντινή αίτηση, με σκοπό την
       ελαχιστοποίηση των κινήσεων του βραχίονα

    3) Αλγόριθμος του ανελκυστήρα (Elevator algorithm)
       Ο βραχίονας κινείται προς μία κατεύθυνση μέχρι να μην υπάρχει αίτηση
       που εκκρεμεί προς τα εκεί. Έτσι, αλλάζει κατεύθυνση.

       Απαιτεί από το λογισμικό να διατηρεί μόνο ένα bit: το bit της
       κατεύθυνσης, το οποίο παίρνει τις τιμές ΠΑΝΩ και ΚΑΤΩ.

       Όταν ολοκληρωθεί η εξυπηρέτηση μιας αίτησης ο οδηγός του δίσκου ελέγχει
       αυτό το bit. Αν έχει τιμή ΠΑΝΩ, ο βραχίονας του δίσκου μετακινείται στην
       επόμενη αίτηση που εκκρεμεί και οδηγεί σε υψηλότερη θέση. Αν δεν υπάρχουν
       εκκρεμείς αιτήσεις για υψηλότερες θέσεις, το bit κατεύθυνσης
       αντιστρέφεται. Αν έχει τιμή ΚΑΤΩ, η μετακίνηση γίνεται με βάση την
       επόμενη αίτηση που εκκρεμεί και οδηγεί σε χαμηλότερη θέση, αν βέβαια
       υπάρχει.

61) Ποιές οι λειτουργίες τις ευσταθούς αποθήκευσης;

    Η ευσταθής αποθήκευση χρησιμοποιεί εάν ζευγάρι πανομοιότυπων δίσκων -
    μονάδων, στους οποίους τα αντίστοιχα μπλοκ συνεργάζονται ώστε να
    σχηματίσουν ένα μπλοκ χωρίς σφάλματα. Αν δεν υπάρχουν σφάλματα, τα
    αντίστοιχα μπλοκ στους δύο δίσκους είναι ίδια.

    1) Ευσταθής εγγραφές (stable writes)
       
       Αποτελείται από την εγγραφή του μπλοκ και στη συνέχεια την ανάγνωσή του
       από εκεί ώστε να επαληθευτεί ότι γράφτηκε σωστά. Αν δεν έχει γραφτεί
       σωστά, η εγγραφή και η ανάγνωση επαναλαμβάνονται n φορές μέχρι να γίνουν
       σωστά.

    2) Ευσταθής ανάγνωση (stable reads)
       
       Εάν προκύψει λανθασμένος κωδικός ECC, η ανάγνωση επαναλαμβάνεται μέχρι n
       φορές. Αν όλες οι αναγνώσεις δώσουν λάθος κωδικό ECC, διαβάζεται το
       αντίστοιχο μπλοκ από εφεδρική μονάδα.

    3) Ανάκαμψη από κατάρευση (crash recovery)

       Μετά από μία κατάρρευση ένα πρόγραμμα ανάκαμψης σαρώνει και τις δύο
       μονάδες και συγκρίνει τα αντίστοιχα μπλοκ. Αν και τα δύο μέρη ενός
       ζεύγους μπλοκ είναι πανομοιότυπα και σωστά, δεν γίνεται καμία ενέργεια.
       Αν το ένα από τα δύο δώσει λάθος κώδικα ECC, αντικαθίστανται από το
       αντίστοιχο σωστό μπλοκ. Αν σε ένα ζεύγος μπλοκ και τα δύο μέρη είναι
       σωστά αλλά διαφορετικά, το μπλοκ της μονάδας 1 αντικαθιστά το αντίστοιχο
       μπλοκ στην μονάδα 2.

62) Ποιοί είναι οι δύο τύποι πόρων;
    
    - Προεκτοπίσιμοι 
      
      Πόροι οι οποίοι μπορούν να αποσπαστούν από μία διεργασία που τους ελέγχει
      χωρίς άσχημες παρενέργειες. πχ η μνήμη.

    - Μη Προεκτοπίσιμοι 

      Πόροι που δεν μπορούν να αποσπαστούν από τη διεργασία που τους κατέχει,
      χωρίς να προκληθούν υπολογιστικά σφάλματα. πχ μονάδες εγγραφής CD.
    
    Γενικά τα αδιέξοδα (deadlocks) αφορούν τους μη προεκτοπίσιμους πόρους.

63) Δώστε τον ορισμό του αδιέξοδου.

    Ένα σύνολο διεργασιών βρίσκεται σε αδιέξοδο αν κάθε διεργασία του συνόλου
    περιμένει ένα συμβάν που μόνο μια άλλη διεργασία του συνόλου μπορεί να
    προκαλέσει.

64) Γράψτε τις συνθήκες για την εμφάνιση αδιεξόδου.

    1) Συνθήκη αµοιβαίου αποκλεισµού (mutual exclusion condition)

       Κάθε πόρος είναι είτε εκχωρημένος σε μία ακριβώς διεργασία είτε
       διαθέσιμος

    2) Συνθήκη κράτησης και αναµονής (hold and wait condition)
       
       Διεργασίες, δεσμεύουν την τρέχουσα στιγμή πόρους που τους εκχωρήθηκαν
       νωρίτερα, μπορούν να ζητήσουν και άλλους.

    3) Συνθήκη μη προεκτόπισης (no preemption condition)

       Πόροι που έχουν εκχωρηθεί σε μία διεργασία δεν μπορούν να αφαιρεθούν από
       αυτή με τη βία. Πρέπει η ίδια η διεργασία να τους αποδεσμεύσει εκούσια.

    4) Συνθήκη κυκλικής αναµονής (circular wait condition)

       Πρέπει να υπάρχει μια κυκλική αλυσίδα δύο ή περισσοτέρων διεργασιών,
       κάθε μία από τις οποίες περιμένει έναν πόρο που κατέχει το επόμενο μέλος
       της αλυσίδας.

65) Ποιοί είναι οι τρόποι ανάκαμψης από αδιέξοδο;

    1) Ανάκαμψη μέσω προεκτόπισης
    2) Ανάκαμψη μέσω ανασκευής (rollback)
    3) Ανάκαμψη μέσω εξάλειψης διεργασιών

66) Τι είναι το κλείδωμα σε δύο φάσεις (two-phase locking);
    
    Αποτελεί μία τεχνική για την αποφυγή αδιέξοδου. Υπάρχουν δύο διακριτές φάσεις:

    1. Η διεργασία προσπαθεί να κλειδώσει όλους του πόρους που χρειάζεται, ένα
       κάθε φορά. Αν επιτύχει, ξεκινάει τη δεύτερη φάση, αλλιώς η διεργασία
       απλώς απενεργοποιεί όλα τα κλειδώματα της και ξεκινάει την πρώτη φάση
       από την αρχή.

    2. Στη δεύτερη φάση, όπου η διεργασία έχει καταφέρει να κλειδώσει όλους
       τους πόρους που χρειάζεται, εκτελεί τις όποιες ενημερώσεις, και
       απενεργοποιεί τα κλειδώματα.

    Δεν είναι γενικά εφαρμόσιμη τεχνική. Χρησιμοποιείται συνήθως για
    βιομηχανικές, χημικές, κτλ διεργασίες και όχι για διεργασίες που έχουμε
    στα λειτουργικά συστήματα.

67) Τι είναι η ομοιόμορφη προσπέλαση μνήμης (UMA - Uniform Memory Access);

    Είναι η ιδιότητα που έχουν ορισμένοι πολυεπεξεργαστές πως κάθε λέξη μνήμης
    μπορεί να διαβαστεί με την ίδια ταχύτητα όπως οποιαδήποτε άλλη.

68) Ποιοί οι τρόποι διασύνδεσης πολυεπεξεργαστών UMA;

    1) Με δίαυλο

       Pros:

       1) Είναι απλός

       Cons:

       1) Εάν ο δίαυλος είναι απασχολημένος τη στιγμή που μία CPU θέλει να
	  διαβάσει ή να γράψει στη μνήμη, η CPU απλώς περιμένει μέχρι ο δίαυλος
	  να τελειώσει. 
       
       Με 2 ή 3 CPU, ο ανταγωνισμός για το δίαυλο είναι διαχειρίσιμος, με 32 ή
       64 CPU ο ανταγωνισμός γίνεται αφόρητος. Το σύστημα θα περιορίζεται
       πλήρως από το εύρος ζώνης του διαύλου, και οι περισσότερες CPU θα είναι
       αδρανείς το μεγαλύτερο χρονικό διάστημα.
       Θα μπορούσαμε να προσθέσουμε κρυφή μνήμη για να ανεχτούμε και
       περισσότερες CPU αλλά και πάλι αυτή η διασύνδεση δεν κλιμακώνεται καλά.

    2) Με σταυρωτό δίκτυο διασύνδεσης

       Pros:

       1) Αποτελεί μη ανασταλτικό δίκτυο (nonblocking network) σε αντίθεση με
          τη διασύνδεση μέσω διαύλου.

       Cons:

       1) Ο αριθμός των διασταυρώσεων αυξάνεται με το n^2

    3) Με δίκτυα μεταγωγής πολλών σταδίων

       Ένας μεταγωγός, πχ 2x2 έχει 2 εισόδους και 2 εξόδους. Τα μηνύματα που
       φτάνουν σε οποιαδήποτε γραμμή εισόδου μπορούν να μεταφερθούν σε
       οποιαδήποτε γραμμή εξόδου.

       Pros:

       1) Στη γενική περίπτωση , αν υπάρχουν n CPU και n μνήμες χρειαζόμαστε
	  log2n στάδια, με n/2 μεταγωγούς ανά στάδιο, οπότε συνολικά
	  χρειάζονται (n/2)log2n μεταγωγοί, αριθμός που είναι πολύ καλύτερος
	  από τις n^2 διασταυρώσεις ειδικά για μεγάλες τιμές του n.

       Cons:

       1) Αποτελεί ανασταλτικό δίκτυο (blocking network)

68) Τι γνωρίζετε για την μη ομοιόμορφη προσπέλαση μνήμης (NUMA - Non Uniform Memory Access);

    Οι πολυεπεξεργαστές UMA με ένα δίαυλο γενικά περιορίζονται στη χρήση το
    πολύ μερικών δεκάδων CPU, ενώ οι πολυεπεξεργαστές με σταυρωτά δίκτυα
    διασύνδεσης χρειάζονται αρκετό (ακριβό) υλικό και δεν είναι και τόσο
    μεγαλύτεροι. Η παρατήρηση αυτή οδηγεί στους πολυεπεξεργαστές NUMA.

    Όπως και οι UMA, παρέχουν ένα μοναδικό χώρο διευθύνσεων σε όλες τις CPU
    αλλά, σε αντίθεση με τους UMA, η πρόσβαση στις τοπικές υπομονάδες μνήμης
    είναι ταχύτερη από την πρόσβαση στις απομακρυσμένες. Επομένως, όλα τα
    προγράμματα UMA μπορούν να εκτελούνται χωρίς αλλαγή σε μηχανές NUMA, αλλά η
    απόδοση θα είναι χειρότερη σε σχέση με τις μηχανές UMA που έχουν το ίδιο
    ρυθμό ρολογιού.

    Οι μηχανές NUMA έχουν τρία κρίσιμα γνωρίσματα:

    1) Υπάρχει ένας και μοναδικός χώρος διευθύνσεων ορατός σε όλες τις CPU
    2) Η πρόσβαση σε απομακρυσμένες μνήμες γίνεται μέσω εντολών LOAD και STORE
    3) Η πρόσβαση στις απομακρυσμένες μνήμες γίνεται βραδύτερα από την πρόσβαση
       στην τοπική μνήμη

69) Τι είναι η αδιακρισία (snooping);
    
    Ειδικά κυκλώματα υλικού εξασφαλίζουν ότι, αν μια λέξη υπάρχει σε δύο ή
    περισσότερες κρυφές μνήμες και κάποια από τις CPU την τροποποιήσει, η λέξη
    αφαιρείται αυτόματα και αδιαίρετα από όλες τις κρυφές μνήμες, ώστε να
    διατηρηθεί η συνέπεια. Η διαδικασία αυτή είναι γνωστή ως αδιακρισία.

70) Περιγράψτε τους τύπους λειτουργικών συστημάτων για πολυεπεξεργαστές.

    1) Κάθε CPU διαθέτει το δικό της λειτουργικό σύστημα
       
       Διαιρείται η μνήμη σε στατικά σε ισάριθμα με τις CPU διαμερίσματα και
       δίνεται σε κάθε CPU η δική της ιδιωτική μνήμη και το δικό της ιδιωτικό
       αντίγραφο του λειτουργικού συστήματος. Ουσιαστικά, οι n CPU λειτουργούν
       σαν n ανεξάρτητοι υπολογιστές.

       Pros:

       1) Το μοντέλο αυτό είναι απλό στην κατασκευή.

       Cons:

       1) Δεν υπάρχει κοινοχρησία διεργασιών. Αν κάποιος χρήστης συνδεθεί στη
	  CPU 1, όλες οι διεργασίες του θα εκτελούνται στη CPU 1. Συνεπώς,
	  είναι πιθανό η CPU 1 να είναι αδρανής ενώ η CPU 2 να έχει μεγάλο
	  φόρτο εργασίας.

       2) Δεν υπάρχει κοινοχρησία σελίδων. Είναι πιθανόν η CPU 1 να έχει
	  αρκετές διαθέσιμες σελίδες ενώ η CPU 2 να σελιδοποιεί συνεχώς. Δεν
	  υπάρχει τρόπος η CPU 2 να δανειστεί μερικές σελίδες από τη CPUT 1,
	  επειδή η κατανομή μνήμης είναι σταθερή.

       3) Αν το λειτουργικό σύστημα διατηρεί μια προσωρινή κρυφή μνήμη για τα
	  μπλοκ δίσκου που έχουν χρησιμοποιηθεί πρόσφατα, κάθε λειτουργικό
	  σύστημα εκτελεί αυτή τη εργασία ανεξάρτητα από τα υπόλοιπα. Επομένως,
	  ένα συγκεκριμένο μπλοκ δίσκου μπορεί να βρίσκεται σε πολλές
	  προσωρινές κρυφές μνήμες ταυτόχρονα και να είναι "βρώμικο", γεγονός
	  που οδηγεί σε ασυνεπή αποτελέσματα. Ο μόνος τρόπος να αποφευχθεί αυτό
	  το πρόβλημα είναι να μη χρησιμοποιούνται προσωρινές κρυφές μνήμες.
	  Αυτό δεν είναι δύσκολο αλλά μειώνει αρκετά την απόδοση.

    2) Πολυεπεξεργαστές κυρίου-υπηρέτη (master - slave)

       Υπάρχει ένα αντίγραφο του λειτουργικού συστήματος και των πινάκων του
       στη CPU 1 και όχι στις υπόλοιπες. Όλες οι κλήσεις συστήματος
       ανάκατευθύνονται για επεξεργασία στη CPU 1. Η CPU 1 μπορεί επίσης να
       εκτελεί διεργασίες χρηστών αν της μένει χρόνος.

       Pros:

       1) Κοινοχρησία διεργασιών. Όταν μία CPU είναι αδρανής, ζητάει από το
	  λειτουργικό σύστημα να της αναθέσει μία διεργασία, και αφού την
	  παραλάβει την εκτελεί.  Επομένως, ποτέ μία CPU δεν είναι αδρανής την
	  ώρα που κάποια άλλη έχει υπερφορτωθεί (καλύτερο load-balancing).

       2) Κοινοχρήσια σελίδων. Οι σελίδες μπορούν να κατανεμηθούν δυναμικά στις
          διεργασίες.

       3) Υπάρχει μόνο μία προσωρινή κρυφή μνήμη, οπότε δεν μπορούν α συμβούν
          ασυνέπειες.

       Cons:

       1) Όταν υπάρχουν πολλές CPU, μπορεί να δημιουργηθεί συμφόρηση στην
	  κύρια, μιας και αυτή θα πρέπει να χειριστεί όλες τις κλήσεις
	  συστήματος που προέρχονται από τις υπόλοιπες.

    3) Συμμετρικοί πολυεπεξεργαστές (SMP - Symmetric Multiprocessor)
       
       Υπάρχει ένα αντίγραφο του λειτουργικού συστήματος στη μνήμη, αλλά μπορεί
       να το εκτελέσει οποιαδήποτε CPU. Όταν γίνεται μία κλήση συστήματος, η
       CPU που την έκανε μεταφέρεται σε κατάσταση λειτουργίας πυρήνα και
       επεξεργάζεται την κλήση συστήματος.

       Pros:

       1) Εξισορροπεί δυναμικά τις διεργασίες και τη μνήμη
       2) Εξαλείφει επίσης της συμφόρηση στη κύρια CPU αφού δεν υπάρχει τέτοια

       Cons:

       1) Επειδή το λειτουργικό σύστημα είναι 1 και το εκτελούν όλες οι CPU,
	  απαιτείται συγχρονισμός, πράγμα που κάνει τον κώδικα του λειτουργικού
	  πιο περίπλοκο. Πρέπει να βρεθούν οι κρίσιμες περιοχές και να
	  προστατευτούν με mutexes.
